% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/attack_evenness.R
\name{ov_aev}
\alias{ov_aev}
\title{Calculate attack evenness}
\usage{
ov_aev(
  x,
  team,
  rotation,
  reference_props = NULL,
  calculate_by = "match_id",
  report_by,
  min_N_attacks = 10,
  detail = FALSE
)
}
\arguments{
\item{x}{data.frame: the \code{plays} data.frame as returned by \code{\link[datavolley:read_dv]{datavolley::read_dv()}} or \code{\link[peranavolley:pv_read]{peranavolley::pv_read()}}}

\item{team}{string: the team to calculate attack evenness for. If not provided, it will be calculated separately for all teams in \code{x}}

\item{rotation}{string: the calculation needs to know what position each player is playing, so that it can work out how many attacks that player should have made under a "perfectly even attack" scenario. This is important for middle hitters, who are usually replaced by the libero in back court and therefore cannot make attacks at those times. The \code{rotation} parameter can be one of:
\itemize{
\item "player_role": use the player roles as specified in the "player_role" column in \code{x}. These are typically the player roles defined in the roster, but it is left to the user to populate this column
\item "SHM": assume a setter-hitter-middle rotation order (i.e. outside hitter is in position 2 when the setter is in 1) and infer the player roles from that
\item "SMH": assume a setter-middle-hitter rotation order and infer the player roles from that
\item "none": don't assume player roles, which will mean that under a "perfectly even attack" scenario, each player (excluding the setter) will be expected to make 20\% of attacks. This option is probably of limited use
}}

\item{reference_props}{data.frame or NULL: if \code{NULL}, the default attack profile will be used (recommended). Otherwise, a data.frame with columns \code{player_role} and \code{p_expected}, where player roles are "middle", "outside", "opposite" and p_expected gives the proportion of attacks that those players are expected to make (when a team is attacking with a perfectly even attack profile)}

\item{calculate_by}{character: names variables in \code{x} to group by when doing the calculations. Note that "lineup" is always used as a calculation grouping variable (it is populated inside the function). See Details}

\item{report_by}{character: names of variables in \code{x} to group by for the final results. Note that results are always effectively grouped by team. Any \code{report_by} variables will be used in addition to team. Note that:
\itemize{
\item \code{report_by} can include "lineup" and/or "setter_id" (these variables are used internally in calculations)
\item \code{report_by} variables must also be present in \code{calculate_by}, with the exception of "lineup" and "setter_id"
}}

\item{min_N_attacks}{integer: minimum number of attacks that must be made in order to be included in the calculations. Attacks are counted by lineup and \code{calculate_by} variables (if any). If \code{calculate_by} is empty and \code{min_N_attacks} is 10, then only lineups that made 10 or more attacks (in total) will be included in the calculations. If \code{min_N_attacks} is 10 and \code{calculate_by} is "match_id", then calculations will be done match by match, using only lineups in a match that made 10 or more attacks in that match}

\item{detail}{logical: if \code{TRUE}, the returned data frame will include additional columns: "aev_sd" (standard deviation of aev across the calculate_by groups), "rally_win_rate", "kill_rate", "rec_eff" (reception efficiency), "N_rallies" (number of rallies played). Note that including these details makes the calculation noticeably slower}
}
\value{
A tibble with at least the columns "team", "aev", and "N_attacks". If \code{detail} was TRUE, additional columns will also be present (see the \code{detail} parameter)
}
\description{
Attack evenness is a measure of how balanced a team's attack is. Teams that rely heavily on one or two attackers will have a relatively low evenness value, whereas teams that use all of their attackers will be higher. See \url{https://untan.gl/attack-evenness.html} for further background.
Evenness is calculated for each lineup used by a team and averaged (weighting by the number of attacks that each lineup made) to get an overall evenness value. Liberos are not expected to attack, and setter attacks (dumps) are ignored. Evenness can be calculated on grouped data: by default, it is calculated by match but averaged over matches when reporting the final result.
}
\details{
Note that calculation by group and averaging will not generally give the same results as calculating the average result in one step (e.g. calculating for several matches and averaging those results will probably not give the same answer as calculating for all matches pooled). This is expected: say that my team under-utilizes a particular hitter in one match, and over-utilizes her in another. In both of those matches my team's evenness will be low, and so averaging those results ought to indicate that on average my team was uneven. But if I pool the data from the two matches, the under-utilization in the first match might be balanced by the over-utilization in the second match, giving a higher attack evenness.
}
\examples{

px <- plays(dv_read(ovdata_example()))

## for a single team
ov_aev(px, rotation = "SHM", team = "GKS Katowice")

## for all teams in px, and with extra detail
ov_aev(px, rotation = "SHM", detail = TRUE)

## for a single team, calculated by set number but aggregate results when reporting
ov_aev(px, team = "GKS Katowice", rotation = "SHM", calculate_by = "set_number")

## for a single team, calculated and reported by set number
ov_aev(px, team = "GKS Katowice", rotation = "SHM", calculate_by = "set_number",
       report_by = "set_number")

}
\references{
\url{https://untan.gl/attack-evenness.html}
}
